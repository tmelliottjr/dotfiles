#!/bin/bash
# filepath: /workspaces/github/script/squash-merge

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to show help
show_help() {
    cat << EOF
Usage: script/squash-merge [OPTIONS] [BASE_BRANCH]

Squash all commits in the current branch into a single commit by:
1. Creating a temporary branch from the base branch
2. Squash merging the current branch into it
3. Resetting the current branch to point to the squashed commit
4. Cleaning up the temporary branch

Arguments:
  BASE_BRANCH    The base branch to squash against (default: main)

Options:
  --dry-run      Show what would happen without executing
  --force        Skip confirmation prompts
  --help, -h     Show this help message

Examples:
  script/squash-merge              # Squash current branch against main
  script/squash-merge master       # Squash current branch against master
  script/squash-merge --dry-run    # Preview the squash operation
  script/squash-merge --force main # Squash without confirmation

This script automates the workflow:
1. git checkout -b temp <base_branch>
2. git merge --squash <current_branch>
3. git commit
4. git checkout <current_branch>
5. git reset --hard temp
6. git branch -d temp
EOF
}

# Parse command line arguments
DRY_RUN=false
FORCE=false
BASE_BRANCH=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --force)
            FORCE=true
            shift
            ;;
        --help|-h)
            show_help
            exit 0
            ;;
        -*)
            print_error "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
        *)
            BASE_BRANCH="$1"
            shift
            ;;
    esac
done

# Set default base branch if not provided
if [[ -z "$BASE_BRANCH" ]]; then
    BASE_BRANCH="main"
fi

# Get current branch
CURRENT_BRANCH=$(git branch --show-current)

if [[ -z "$CURRENT_BRANCH" ]]; then
    print_error "Not on a branch (detached HEAD state)"
    exit 1
fi

# Validate we're not on the base branch
if [[ "$CURRENT_BRANCH" == "$BASE_BRANCH" ]]; then
    print_error "Cannot squash the base branch '$BASE_BRANCH' against itself"
    print_warning "Please switch to your feature branch first"
    exit 1
fi

# Check if base branch exists
if ! git show-ref --verify --quiet "refs/heads/$BASE_BRANCH"; then
    print_error "Base branch '$BASE_BRANCH' does not exist"
    exit 1
fi

# Check for clean working directory
if ! git diff --quiet || ! git diff --cached --quiet; then
    print_error "Working directory is not clean. Please commit or stash your changes."
    exit 1
fi

# Show what will happen
print_status "Current branch: $CURRENT_BRANCH"
print_status "Base branch: $BASE_BRANCH"

# Count commits to be squashed
COMMIT_COUNT=$(git rev-list --count "$BASE_BRANCH..$CURRENT_BRANCH")
print_status "Commits to squash: $COMMIT_COUNT"

if [[ "$COMMIT_COUNT" -eq 0 ]]; then
    print_warning "No commits to squash. Branch '$CURRENT_BRANCH' is up to date with '$BASE_BRANCH'"
    exit 0
fi

# Show commits that will be squashed
echo
print_status "Commits that will be squashed:"
git log --oneline "$BASE_BRANCH..$CURRENT_BRANCH"
echo

if [[ "$DRY_RUN" == "true" ]]; then
    print_status "DRY RUN - Would execute the following commands:"
    echo "1. git checkout -b temp-squash-$CURRENT_BRANCH $BASE_BRANCH"
    echo "2. git merge --squash $CURRENT_BRANCH"
    echo "3. git commit"
    echo "4. git checkout $CURRENT_BRANCH"
    echo "5. git reset --hard temp-squash-$CURRENT_BRANCH"
    echo "6. git branch -d temp-squash-$CURRENT_BRANCH"
    exit 0
fi

# Confirmation prompt
if [[ "$FORCE" != "true" ]]; then
    echo -n "Do you want to squash these $COMMIT_COUNT commits? (y/N): "
    read -r response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        print_warning "Operation cancelled"
        exit 0
    fi
fi

# Generate unique temporary branch name
TEMP_BRANCH="temp-squash-$CURRENT_BRANCH"

# Make sure temp branch doesn't already exist
if git show-ref --verify --quiet "refs/heads/$TEMP_BRANCH"; then
    print_error "Temporary branch '$TEMP_BRANCH' already exists"
    print_warning "Please delete it first: git branch -D $TEMP_BRANCH"
    exit 1
fi

print_status "Starting squash merge process..."

# Step 1: Create temporary branch from base branch
print_status "Creating temporary branch '$TEMP_BRANCH' from '$BASE_BRANCH'"
git checkout -b "$TEMP_BRANCH" "$BASE_BRANCH"

# Step 2: Squash merge the feature branch
print_status "Squash merging '$CURRENT_BRANCH' into temporary branch"
git merge --squash "$CURRENT_BRANCH"

# Step 3: Commit the changes
print_status "Committing squashed changes"
git commit

# Step 4: Go back to feature branch and reset to temp branch
print_status "Switching back to '$CURRENT_BRANCH'"
git checkout "$CURRENT_BRANCH"

print_status "Resetting '$CURRENT_BRANCH' to squashed commit"
git reset --hard "$TEMP_BRANCH"

# Step 5: Delete temporary branch
print_status "Cleaning up temporary branch"
git branch -d "$TEMP_BRANCH"

print_success "Successfully squashed $COMMIT_COUNT commits in '$CURRENT_BRANCH'"
print_status "Your branch now contains a single commit with all changes"

# Show the result
echo
print_status "Result:"
git log --oneline -1
echo

print_success "Squash merge completed!"