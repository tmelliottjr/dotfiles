#!/bin/bash
# Search for patterns in modified/staged and untracked files

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default values
search_pattern=""
file_filter=""
verbose=false
context_lines=""

usage() {
    echo "Usage: $0 [OPTIONS] <search_pattern> [grep_options]"
    echo ""
    echo "Search for a pattern in modified/staged and untracked files"
    echo ""
    echo "OPTIONS:"
    echo "  -t, --type EXT     Filter files by extension (e.g., rb, js, py)"
    echo "  -v, --verbose      Show which files are being searched"
    echo "  -C, --context N    Show N lines of context around matches"
    echo "  -A, --after N      Show N lines after matches"
    echo "  -B, --before N     Show N lines before matches"
    echo "  -h, --help         Show this help message"
    echo ""
    echo "EXAMPLES:"
    echo "  $0 'function'           # Search for 'function' in all changed files"
    echo "  $0 -t js 'console'      # Search for 'console' only in .js files"
    echo "  $0 -v -C 2 'TODO'       # Search for 'TODO' with 2 lines of context"
}

log() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -t|--type)
            file_filter="$2"
            shift 2
            ;;
        -v|--verbose)
            verbose=true
            shift
            ;;
        -C|--context)
            context_lines="-C $2"
            shift 2
            ;;
        -A|--after)
            context_lines="-A $2"
            shift 2
            ;;
        -B|--before)
            context_lines="-B $2"
            shift 2
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            error "Unknown option: $1"
            usage
            exit 1
            ;;
        *)
            if [[ -z "$search_pattern" ]]; then
                search_pattern="$1"
                shift
                break
            fi
            ;;
    esac
done

if [[ -z "$search_pattern" ]]; then
    error "Search pattern is required"
    usage
    exit 1
fi

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    error "Not in a git repository"
    exit 1
fi

# Get modified/staged files (excluding deleted) and untracked files
files=$(
    {
        git diff --name-only --diff-filter=AM
        git ls-files --others --exclude-standard
    } | sort -u
)

if [[ -z "$files" ]]; then
    warning "No changed files found."
    exit 0
fi

# Apply file type filter if specified
if [[ -n "$file_filter" ]]; then
    files=$(echo "$files" | grep "\.$file_filter$" || true)
    if [[ -z "$files" ]]; then
        warning "No changed .$file_filter files found."
        exit 0
    fi
fi

file_count=$(echo "$files" | wc -l)
if [[ "$verbose" == true ]]; then
    log "Searching in $file_count file(s):"
    echo "$files" | sed 's/^/  /'
    echo ""
fi

# Perform the search
if echo "$files" | xargs -r grep -n --color=auto $context_lines "$@" "$search_pattern"; then
    success "Search completed"
else
    exit_code=$?
    if [[ $exit_code -eq 1 ]]; then
        warning "No matches found for pattern: $search_pattern"
    else
        error "Search failed with exit code: $exit_code"
        exit $exit_code
    fi
fi
